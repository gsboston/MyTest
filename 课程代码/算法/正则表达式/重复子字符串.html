<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

    <script>
        // https://leetcode-cn.com/problems/repeated-substring-pattern/
        // 给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。

        // 示例 1:
        // 输入: "abab"
        // 输出: True

        // 解释: 可由子字符串 "ab" 重复两次构成。
        // 示例 2:
        // 输入: "aba"
        // 输出: False

        // 正则权威网站
        // https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions

        // 模式匹配
        /(foo) (bar) \1 \2/
        // 中的（foo） （bar）匹配并记住字符串“foo bar foo bar”中前两个单词，
        // 模式中的\1 \2 是匹配字符串中的后两个单词
        // \1 \2 \n 用在正在表达式的匹配环节，在替换环节，要用$1 $2 $n
        // 如 'bar foo'.replace(/(……) (……)/,'$2,$1')

        function fn(str) {
            var reg = /^(\w+)\1+$/;

            return reg.test(str);
        }
        
        
        // ^ 匹配开头 $匹配结尾
        // 数量 {0,} {3,}
        // * === {0,}  匹配前一个表达式0次或多次
       
        // + === {1,}  匹配前面一个表达式1次或者多次

        // ? === {0,1} 匹配前面一个表达式0次或者1次。等价于 {0,1}。跟在* + ? {} 后，将会使量词变为非贪婪的。
        // 例如，对 "123abc" 应用 /\d+/ 将会返回 "123"，如果使用 /\d+?/,那么就只会匹配到 "1"。
        // 还可以运用于先行断言，见下面

        // .匹配除换行符之外任意字符 例如，/.n/将会匹配 "nay, an apple is on the tree" 中的 'an' 和 'on'，
        // 但是不会匹配 'nay'。
        
        // (x) 匹配x并且记住匹配项。
        // /(foo) (bar) \1 \2/
        // 中的(foo) (bar)匹配并记住字符串“foo bar foo bar”中前两个单词，
        // 模式中的\1 \2 是匹配字符串中的后两个单词
        // \1 \2 \n 用在正在表达式的匹配环节
        // 在正则表达式的替换环节，则要使用像 $1、$2、$n 这样的语法，例如，'bar foo'.replace( /(...) (...)/, '$2 $1' )。

        // (?:x) 匹配x但是不记住匹配项，叫做非捕获括号，
        // 示例表达式 /(?:foo){1,2}/。如果表达式是 /foo{1,2}/，{1,2}将只对 ‘foo’ 的最后一个字符 ’o‘ 生效。
        // 如果使用非捕获括号，则{1,2}会匹配整个 ‘foo’ 单词。

        // x(?=y) 匹配'x'仅仅当'x'后面跟着'y'.这种叫做先行断言。
        // 例如，/Jack(?=Sprat)/会匹配到'Jack'仅仅当它后面跟着'Sprat'。/Jack(?=Sprat|Frost)/匹配‘Jack’仅仅当它后面跟着'Sprat'或者是‘Frost’。但是‘Sprat’和‘Frost’都不是匹配结果的一部分。

        // (?<=y)x 匹配'x'仅仅当'x'前面是'y'.这种叫做后行断言。
        // 例如，/(?<=Jack)Sprat/会匹配到' Sprat '仅仅当它前面是' Jack '。/(?<=Jack|Tom)Sprat/匹配‘ Sprat ’仅仅当它前面是'Jack'或者是‘Tom’。但是‘Jack’和‘Tom’都不是匹配结果的一部分。

        // x(?!y) 仅仅当'x'后面不跟着'y'时匹配'x'，这被称为正向否定查找。
        // 例如，仅仅当这个数字后面没有跟小数点的时候，/\d+(?!\.)/ 匹配一个数字。正则表达式/\d+(?!\.)/.exec("3.141")匹配‘141’而不是‘3.141’

        // (?<!y)x 仅仅当x前面不跟着y时匹配x，称为反向否定查找
        // /(?<!-)\d+/ 仅仅当前面不是-的时候匹配数字
        // /(?<!-)\d+/.exec('3') 匹配 "3".
        // /(?<!-)\d+/.exec('-3') 匹配不到，因为前面有-

        // {n} 匹配次数
        // {n,} 匹配>=n次
        // {n,m} n=< <=m

        // [xyz] 一个字符集合，匹配方括号中的任意字符，可以使用破折号(-)指定一个字符范围，
        // 对于(.) (*)这样的特殊富豪，在字符集中没有特殊意义，可以不进行转义，不过转义也是起作用的。
        // [a-d] 等同于 [abcd]
        // 字符集合中没有顺序限制 如：/[.a-z]+/.test('test.n.in') === true 

        // [^xyz] 反向字符集，匹配没有包含方括号中的字符。

        // [\b] 匹配退格

        // \b 匹配一个词的边界。一个词的边界就是一个词不被另外一个“字”字符跟随的位置或者没有其他“字”字符在其前面的位置。注意，一个匹配的词的边界并不包含在匹配的内容中。换句话说，一个匹配的词的边界的内容的长度是0
        // 使用"moon"举例：
        // /\bm/匹配“moon”中的‘m’；
        // /oo\b/并不匹配"moon"中的'oo'，因为'oo'被一个“字”字符'n'紧跟着。
        // /oon\b/匹配"moon"中的'oon'，因为'oon'是这个字符串的结束部分。这样他没有被一个“字”字符紧跟着。
        // /\w\b\w/将不能匹配任何字符串，因为在一个单词中间的字符永远也不可能同时满足没有“字”字符跟随和有“字”字符跟随两种情况。

        // \B 匹配一个非单词边界。他匹配一个前后字符都是相同类型的位置：都是“字”字符或者都不是“字”字符。
        // 一个字符串的开始和结尾都被认为不是“字”字符，或者空字符串。
        // 例如，/\B../匹配"noonday"中的'oo', 而/y\B../匹配"possibly yesterday"中的’yes‘


        // 方法	     描述
        // exec	    一个在字符串中执行查找匹配的RegExp方法，它返回一个数组（未匹配到则返回 null）。
        // test	    一个在字符串中测试是否匹配的RegExp方法，它返回 true 或 false。
        // match	一个在字符串中执行查找匹配的String方法，它返回一个数组，在未匹配到时会返回 null。
        // matchAll	一个在字符串中执行查找所有匹配的String方法，它返回一个迭代器（iterator）。
        // search	一个在字符串中测试匹配的String方法，它返回匹配到的位置索引，或者在失败时返回-1。
        // replace	一个在字符串中执行查找匹配的String方法，并且使用替换字符串替换掉匹配到的子字符串。
        // split	一个使用正则表达式或者一个固定字符串分隔一个字符串，并将分隔后的子字符串存储到数组中的 String 方

        // 当你想要知道在一个字符串中的一个匹配是否被找到，你可以使用 test 或 search 方法；
        // 想得到更多的信息（但是比较慢）则可以使用 exec 或 match 方法。如果你使用exec 或 match 方法并且匹配成功了，
        // 那么这些方法将返回一个数组并且更新相关的正则表达式对象的属性和预定义的正则表达式对象（详见下）。
        // 如果匹配失败，那么 exec 方法返回 null（也就是false）。

    </script>
</body>

</html>